<?php
/**
 * @file
 * CALS Importer Module.
 */
/**
 * set memory limit and max execution times to higher than normal!
 */
  ini_set('memory_limit', '1024M');
  ini_set('max_execution_time', '600');
  //the MARC namespace
  define("NAME_SPACE", "http://www.loc.gov/MARC21/slim");
  //require these files..
  module_load_include('inc', 'cals_importer', 'cals_importer.misc');
  module_load_include('inc', 'cals_importer', 'cals_importer.fieldcollections');
  module_load_include('inc', 'cals_importer', 'cals_importer.mappings');
  module_load_include('inc', 'cals_importer', 'cals_importer.marcxml');
  module_load_include('inc', 'cals_importer', 'cals_importer.s3paths');
  module_load_include('inc', 'cals_importer', 'cals_importer.createrecords');
  module_load_include('inc', 'cals_importer', 'cals_importer.clean_up');
  module_load_include('inc', 'cals_importer', 'cals_importer.deduper');
  module_load_include('inc', 'cals_importer', 'cals_importer.marcxmlfilebuilder');
  module_load_include('inc', 'cals_importer', 'cals_importer.corsS3');
  module_load_include('inc', 'entity', 'includes/entity.controller');




/**
 * Implements hook_menu().
 */
function cals_importer_menu() {
  $items = array();
  
  
   $items['admin/config/cals_importer/normalization'] = array(
    'title' => 'Configure normalization settings',
    'description' => 'Configuration for the normalization settings in CALS IMPORTER',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cals_importer_config_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'cals_importer.admin.inc',
  );

  
 
  /*
   * Parses S3 sets, can be invoked directly - e.g:
   * http://me/cals_staging/admin/content/cals/batch-update-s3-paths/5429
   *
   * See: content/cals/s3-record-sets
   *
   */

  $items['admin/content/cals/batch-update-s3-paths'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_batch_update_s3_paths',
    'title' => 'Update S3 Paths',
    'page arguments' => array(4),  
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 100,
  );

  
  /**
   * Fix to move OCLC entries out of the system control field
   * - deactivated so we don't run accidentally
   */
  $items['node/%node/fix-oclc-entry'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_update_oclc_numbers_single_node',
    'title' => 'Fix OCLC entry',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
  
  );  
  
  /**
   * Parses S3 sets via node page
   */

  $items['node/%node/parse-s3-path-node'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_batch_update_s3_paths_by_node',
    'file' => "cals_importer.s3paths.inc",
    'title' => 'Parse S3 Paths',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
  
  );
  
  

  $items['admin/content/cals/parse-org-emails'] = array(
    'title' => 'Update Organizational Contact Emails from CSV file',
    'access arguments' => array('administer site configuration'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cals_org_emails_import_form'),
    'file' => 'cals_importer.orgs.inc',
  );
  
  $items['admin/content/cals/test-load-org-emails-csv'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_get_array_org_emails',
    'title' => "Test Load CSV file",
    'type' => MENU_CALLBACK,
    //'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
    'access arguments' => array('parse s3 paths'),
    'file' => 'cals_importer.orgs.inc',
  
  );

  $items['node/%node/parse-marcxml-new'] = array(
    'page callback' => '_cals_import_skeletal_records',
    'title' => "Generate / Update Stub Entries",
    'type' => MENU_CALLBACK,
    //'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
    'access arguments' => array('parse s3 paths'),
  
  );
  $items['node/%node/parse-marcxml-new2'] = array(
    'page callback' => '_cals_importer_create_repo_items',
    'file' => "cals_importer.createrecords.inc",
    'title' => "Generate / Update Stub Entries 2",
    'type' => MENU_CALLBACK,
    //'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
    'access arguments' => array('parse s3 paths'),
  );
  $items['node/%node/preview-titles'] = array(
    'page callback' => '_cals_importer_preview_repo_items',
    'file' => "cals_importer.createrecords.inc",
    'title' => "Preview New Titles in Collection",
    'type' => MENU_CALLBACK,
    //'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
    'access arguments' => array('parse s3 paths'),
  );
  
  
  $items['node/%node/parse-record'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_update_repository_item',
    'title' => 'Parse MARC/XML',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
    'file' => "cals_importer.marcxml.inc",
  
  );

  $items['node/%node/normalize-record'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_normalize_record_value',
    'file' => "cals_importer.clean_up.inc",
    'title' => 'Normalize Record',
    'description' => 'Scrubs the title, author and publisher values',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 150,
  
  );
  $items['node/%node/normalize-record-preview'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_normalize_record_value_preview',
    'file' => "cals_importer.clean_up.inc",
    'title' => 'Preview Creator Normalization',
    'description' => 'Preview the normalization',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 150,
  
  );
  

  $items['node/%node/generate-marc-856'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_add_856_tag',
    'file' => "cals_importer.clean_up.inc",
    'title' => 'Generate MARC 856',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 150,
  
  );
  
  $items['node/%node/generate-marc-output'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_generate_marcxml_file',
    'file' => "cals_importer.marcxmlfilebuilder.inc",
    'title' => 'Generate MARC Output File',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 200,
  
  );


  $items['node/%node/convert-s3-paths'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_update_cors_file_table',
    'file' => "cals_importer.corsS3.inc",
    'title' => 'update S3 -> CORS path!',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 200,
  );
  
  //generate cors s3 file via s3 path (field collection)
  $items['admin/%node/update-file-upload-from-field-collection'] = array(
    'page callback' => '_cals_update_filecollection_file',
    'title' => "Update via Field Collection",
    'type' => MENU_CALLBACK,
    'page arguments' => array(1,3),
    'weight' => 100,
    'access arguments' => array('parse s3 paths'),
    'file' => 'cals_importer.corsS3.inc',
  
  );
  
  /*
    


  $items['node/%node/parse-access-rights'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_parse_licensed_access',
    'title' => 'Parse 506 (access'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
  
  );  


   */   
  
  /*

  $items['admin/content/cals/update-isbn-length'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_increase_field_size',
    'title' => 'Update ISBN Field Size (admin only'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'cals_importer.misc.inc',
    'weight' => 100,
  
  );  
    
   */   
  
  //to deprecate next round of development?
  
  /*
  $items['node/%node/parse-sys-control-num'] = array(
    'access arguments' => array('administer site configuration'),
    'page callback' => '_cals_importer_update_system_control_numbers',
    'title' => 'Parse System Control Number',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page arguments' => array(1),
    'weight' => 100,
  
  );

  */
  return $items; 

}


/**
 * Implements hook_permission().
 */
function cals_importer_permission() {
  return array(
    'dedupe records' => array(
      'title' => t('Dedupe Repo Items'),
      'description' => t('Dedupe Repo Items.'),
    ),
   'parse s3 paths' => array(
      'title' => t('Parse S3 paths'),
      'description' => t('Parse S3 Paths.'),
    ),
    'parse marc records' => array(
      'title' => t('Parse MARC records'),
    ),
    'generate repo records' => array(
      'title' => t('Generate New Repository Items'),
    ),
    'parse 506' => array(
      'title' => t('Parse / Update 506 entries'),
      'description' => t(''),
    ),
  );
}
/**
 * Implements action_info().
 */
function cals_importer_action_info() {
  return array(
    //the main MARC XML parser
    '_cals_importer_update_repository_items' => array(
      'label' => t('1. Generate Full Record (parse MARC XML)'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),

    //batch update title field, stripping out trailing slashes, etc.
    '_cals_normalize_record_values' => array(
      'label' => t('2. Normalize Title, Publisher, Creators'),
      'type' => 'node',
      'configurable' => FALSE, //TRUE,
      'triggers' => array('any'),
    ),

    //batch update Genre, Subjects.
    '_cals_normalize_performer' => array(
      'label' => t('CALS: Normalize Performer Values'),
      'type' => 'entity',
      'configurable' => FALSE, //TRUE,
      'triggers' => array('any'),
    ),
    //batch titlecase creator names
    '_cals_titlecase_creators' => array(
      'label' => t('CALS: Convert Creators to Title Case'),
      'type' => 'entity',
      'configurable' => FALSE, //TRUE,
      'triggers' => array('any'),
    ),

    
    
    //batch update Genre, Subjects.
    '_cals_normalize_taxonomy_terms2' => array(
      'label' => t('CALS: Normalize Taxonomy Terms 2'),
      'type' => 'taxonomy_term',
      'configurable' => FALSE, //TRUE,
      'triggers' => array('any'),
    ),

    
    //batch update Genre, Subjects.
    '_cals_normalize_taxonomy_terms' => array(
      'label' => t('CALS: Normalize Taxonomy Terms'),
      'type' => 'entity',
      'configurable' => FALSE, //TRUE,
      'triggers' => array('any'),
    ),
    //bulk update to generate marc xml strings w/ 856 tag
    '_cals_importer_generate_marc_xml_856' => array(
      'label' => t('3. Generate MARC with 856 strings'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),

    //batch generate MARC XML files and attach to original recordset
    '_cals_importer_generate_marcxml_files' => array(
      'label' => t('4. Generate downloadable MARC XML files'),
      'type' => 'node',
      'configurable' => TRUE,
      'triggers' => array('any'),
    ),


    //batch generate MARC XML files from all files that include 856 tag
    '_cals_importer_generate_marcxml_files_all_records' => array(
      'label' => t('CALS: Generate downloadable MARC XML files (entire recordset)'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),

    
    //preview changes to Author
    '_cals_importer_normalize_creators_preview_vbo' => array(
      'label' => t("CALS: Preview Creator Normalization"),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),       
    //batch update to just the system control numbers
    '_cals_importer_fix_oclc_numbers_batch' => array(
      'label' => t("CALS: Fix Dave's STUPID OCLC bug!"),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),        
    //batch update to just the system control numbers
    '_cals_importer_update_system_control_numbers' => array(
      'label' => t('CALS: Update System Control Numbers'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),
    //batch update to adjust/update the 506 access rights permissions
    '_cals_importer_update_licensed_access' => array(
      'label' => t('CALS: Update Access Restrictions'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),
    //batch update to update org email fields based on J. Schatz's CVS file
    '_cals_update_org_emails' => array(
      'label' => t('CALS: Update Organization Emails'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
      'file' => 'cals_importer.orgs.inc',
    ),



    //batch dedupe marc xml records
    '_cals_dedupe_035' => array(
      'label' => t('CALS: Dedupe on 035 matches'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),
    //batch dedupe org nodes based on ill code (field_library_code)
    '_cals_dedupe_orgs_by_illcode' => array(
      'label' => t('CALS: Dedupe orgs based on ILL Code matches'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),
    //_cals_run_batch_update_field_collection_s3_path
    //batch copy existing S3 paths to Field Collection "field_file_resource"
    '_cals_run_batch_update_field_collection_s3_path' => array(
      'label' => t('CALS: Copy S3 paths to Field Collection'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),
  
  );
}



/**
 * Implements hook_custom_theme().
 *   - disabled for now.
 */
function cals_importer_custom_themexxx() {

  $alias = drupal_get_path_alias();
  if(strpos($alias, "admin/") !== FALSE) {
    return "rubik";
  }

}

/**
 * VBO form to update the filename used in the MARC XML generation.
 */
function _cals_importer_generate_marcxml_files_form($options) {
  $form = array();
  $filename = (is_numeric(arg(1)) && arg(0) == 'node' ) ? 'nnels_marcxml' . "_" . arg(1) . '.xml' : 'nnels_marcxml,xml';
  $form['filename'] = array(
    '#type' => 'textfield', 
    '#title' => t('filename'),
    '#description' => t("Please provide a filename."),
    '#required' => TRUE,
    '#default_value' => $filename,
  );
  return $form;

}
function _cals_importer_generate_marcxml_files_submit($form, $form_state) {
  $return = array();
  $return['filename'] = $form_state['values']['filename'];
  return $return;
}
/*

    //batch update creator field, stripping out trailing periods, commas, etc.
    '_cals_clean_up_creators' => array(
      'label' => t('CALS: Normalize authors / creators'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
      //'file' => 'cals_importer.clean_up.inc',
    ),

    //batch update creator field, stripping out trailing periods, commas, etc.
    '_cals_normalize_publishers' => array(
      'label' => t('CALS: Normalize publishers'),
      'type' => 'node',
      'configurable' => FALSE,
      'triggers' => array('any'),
    ),


*/

/**
 * Implementation of hook_menu_alter().
 * Remember to clear the menu cache after adding/editing this function.
 */
function cals_importer_menu_alter(&$items) {
  // Removing certain local navigation tabs that are either undesired or need to be custom relocated.
  // Set these tabs to MENU_CALLBACK, so they still register the path, but just don't show the tab:
  $items['node/%node/parse-access-rights']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/parse-record']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/parse-marcxml-new']['access callback'] = '_cals_importer_tab_checker';
  $items['node/%node/parse-marcxml-new2']['access callback'] = '_cals_importer_tab_checker';
  
  $items['node/%node/normalize-publisher']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/normalize-title']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/clean-author']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/generate-marc-856']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/generate-marc-output']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/convert-s3-paths']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/normalize-record']['access callback'] = '_cals_importer_tab_checker_parse_record';
  $items['node/%node/normalize-record-preview']['access callback'] = '_cals_importer_tab_checker_parse_record';
  
  $items['node/%node/parse-s3-path-node']['access callback'] = '_cals_importer_tab_checker_parse_s3_paths';

}

function _cals_importer_tab_checker_parse_record() {
  global $user;
  //todo - change to permission
  if (user_access('parse marc records') && arg(0) == 'node') {
    $n = node_load(arg(1));
    RETURN ($n->type == 'repository_item') ? TRUE : FALSE;
  }
  return FALSE;
}

function _cals_importer_tab_checker() {
  global $user;
  //todo - change to permission
  if ( user_access('parse s3 paths') && arg(0) == 'node') {
    $n = node_load(arg(1));
    RETURN ($n->type == 'record_set') ? TRUE : FALSE;
  }
  return FALSE;
}

function _cals_importer_tab_checker_parse_s3_paths() {
  global $user;
  //todo - change to permission
  if ( user_access('parse s3 paths') && arg(0) == 'node') {
    $n = node_load(arg(1));
    RETURN ($n->type == 's3_record_set') ? TRUE : FALSE;
  }
  return FALSE;

}


function cals_importer_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  //dpm($form_id);
  switch($form_id) {
    
    case "field_collection_item_formx":
      //$form['#submit'][] = 
      $form['nid'] = array('#type' => 'value', '#default_value' => 9724);
      $form['actions']['submit']['#submit'][] = '_cals_importer_s3_cors_field_submit';
      dpm($form);
      
      break;
  }

}

function cals_importer_entity_presave($entity, $type) {
  if ($type == 'field_collection_item' && $entity->field_name == 'field_file_resource') {
    //printAndDie($type, $entity);
  }
}

 
function _cals_importer_s3_cors_field_submit($form, &$form_state){
  $filepath = "NO";
  //printAndDie($form_state['values']['field_s3_to_cors_update'][LANGUAGE_NONE][0]['value']);
  if($form_state['values']['field_s3_to_cors_update'][LANGUAGE_NONE][0]['value'] == 1) {
    if(isset($form_state['values']['nid']) && !empty($form_state['values']['field_s3_path'])) {
      $node = node_load($form_state['values']['nid']); 
      $filepath = $form_state['values']['field_s3_path'][LANGUAGE_NONE][0]['value'];
      $file = _cals_importer_file_updater($node, $filepath);
    } 
    $form_state['values']['field_s3_file_upload'][LANGUAGE_NONE][0] = (array)$file;
  }

}



/**
 * Custom function to return node with duplicate S3 paths. Used in conjunction with 
 * view: admin/content/cals/repo-items/multi-files/duplicate-s3-paths-refs
 */
function _cals_get_node_with_duplicate_s3($data) {
  if (!empty($data->field_data_field_s3_path_field_s3_path_value)) {
    $items = array();
    $rs = db_query(
      "SELECT entity_id as nid, field_s3_path_value as s3
      FROM field_data_field_s3_path
      where 
      entity_id != :nid and field_s3_path_value = :s3 ", 
      
      array(":nid" => $data->nid, ":s3" => $data->field_data_field_s3_path_field_s3_path_value) );
    
    foreach ($rs as $row) {
        $n = node_load($row->nid);
        if ($n) $items[] = l($n->title, "node/" . $n->nid);
    }
    if (count($items)){
      $vars = array("items" =>  $items, "title" => '', "type" => 'ul', "attributes" => array('id' => 'nodes') );
      return theme_item_list($vars);    
    }
  }
  return "NULL";
}


function _cals_importer_query_duplicate_titles($type) {

  $vals = array(0);
  $arr = array(
    "title" => array("tbl" => "field_data_title_field", "field" => "title_field_value"),
    "isbn" => array("tbl" => "field_data_field_isbn", "field" => "field_isbn_value"),
    "oclc" => array("tbl" => "field_data_field_oclc_number", "field" => "field_oclc_number_value"),
    "syscontrolnumber" => array("tbl" => "field_data_field_system_control_number", "field" => "field_system_control_number_value"),
  ); 
  if(array_key_exists($type, $arr)) {
    $field = $arr[$type]['field'];
    $tbl = $arr[$type]['tbl'];
    //printAndDie("HERE?", $type);
  
    //, $field as field
    $rs = db_query("select entity_id as nid
      from {" . $tbl . "} 
      where $field != '' and $field
      in (select $field 
         from {" . $tbl . "}
         group by $field
         having count(*) > 1)
      order by $field");
    foreach ($rs as $row) {
      $vals[] = $row->nid;
    } 
    
  }
  return $vals;

}


/**
 * Implements hook_views_query_alter().
 */
function cals_importer_views_query_alter(&$view, &$query) {
  switch ($view->name . ":" . $view->current_display) {
  
  	//lets find upper case creators; need to use BINARY operator
  	case "cals_creators:page_1":
  	
			$query->where[1]['conditions'][0]['value'] = "^[A-Z][A-Z]";
			$query->where[1]['conditions'][0]['operator'] = "rlike BINARY";
     
  		break;
  
    //system control number duplicates
    case "repository_items_duplicates:page_1":
      //custom query to find duplicate system control numbers  
      $vals = array();
      $rs = db_query("select nid, title
        from {node} n 
        where title != '' and title
        in (select title 
           from {node}
           group by title
           having count(*) > 1)
        order by title");
      foreach ($rs as $row) {
        $vals[] = $row->nid;
      }
      $vals = _cals_importer_query_duplicate_titles("title");
      $query->where[1]['conditions'][] = array(
            "field" => "node.nid",
            "value" => $vals,
            "operator" => "in",
      );      
      
      //printAndDie($query);  
    
      break;
      
    //isbn duplicates
    case "repository_items_duplicates:page_2":
      $vals = _cals_importer_query_duplicate_titles("isbn");
      $query->where[1]['conditions'][1] = array(
            "field" => "node.nid",
            "value" => $vals,
            "operator" => "in",
      );      
      break;
    //isbn duplicates
    case "repository_items_duplicates:page_3":
      $vals = _cals_importer_query_duplicate_titles("oclc");
      $query->where[1]['conditions'][1] = array(
            "field" => "node.nid",
            "value" => $vals,
            "operator" => "in",
      );      
      break;
      
    //custom query to find duplicate system control numbers  
    case "repository_items_duplicates:page_8":
    case "repository_item_admin_views:page_8":
      $vals = _cals_importer_query_duplicate_titles("syscontrolnumber");
      $query->where[1]['conditions'][1] = array(
            "field" => "node.nid",
            "value" => $vals,
            "operator" => "in",
      );      
        
      break;

  } 

  switch ($view->name) {
  
    case "repository_items_with_field_collections":
    
      if ($view->current_display == 'page_2' || $view->current_display == 'page_4' ) {
        $sql = 
        "SELECT entity_id as nid, field_s3_path_value as s3, COUNT( field_s3_path_value ) 
          FROM field_data_field_s3_path
          GROUP BY field_s3_path_value
          HAVING (COUNT( field_s3_path_value ) > 1)";
        $rs = db_query($sql);
        foreach ($rs as $row) {
          $arr[] = $row->s3;
          //printPre($row);
        }
        //die;
        $query->where[1]['conditions'][2] = array(
           'field' => "field_data_field_s3_path.field_s3_path_value",
           'value' => $arr, //array($subq),
           'operator' => 'in', 
          );
      }
      break;
  
    case "repository_items_deduplicate2":
    case "repo_items_bulk_deduper":
      if ($view->current_display == 'page') {
        $sql = 
        "SELECT field_data_field_system_control_number.field_system_control_number_value as val " .
          "FROM field_data_field_system_control_number " .
          "GROUP BY field_system_control_number_value " .
          "HAVING COUNT(*) > 1 " .
          "ORDER BY field_system_control_number_value";
        $rs = db_query($sql);
        foreach ($rs as $row) {
          $arr[] = $row->val;
        }
        $query->where[1]['conditions'][2] = array(
           'field' => "field_data_field_system_control_number.field_system_control_number_value",
           'value' => $arr, //array($subq),
           'operator' => 'in', 
          );
      }
      break;
    

      
    case "organizations_vbo":
      if ($view->current_display == 'page_2') {
        //custom query to find duplicate system control numbers  
        $vals = array();
        $rs = db_query("select entity_id, field_library_code_value
          from {field_data_field_library_code} 
          where field_library_code_value
          
          in (select field_library_code_value 
             from {field_data_field_library_code}
             group by field_library_code_value
             having count(*) > 1)
          order by field_library_code_value");
        foreach ($rs as $row) {
          $vals[] = $row->entity_id;
        }
    
        $query->where[1]['conditions'][1] = array(
              "field" => "node.nid",
              "value" => $vals,
              "operator" => "in",
        );      
        
      }
    
      break;  
  
  }//end switch


} 

/**
 * import / create skeletal marc records, i.e., just the title
 *
 * @param $node
 *   the node passed to the parser
 */

function cals_importer_node_view($node, $view_mode, $langcode) {
  switch ($node->type) {
    case "record_set":
      if ($view_mode == 'full' && (user_access("generate repo records") || user_access("parse marc records")) ) {
        $label = t("Generate new stub Repository Records");
        if (count($node->field_parsed_nodes)) {
          $label = t("Update existing Repository Records (titles + S3 paths)");
        }
        $node->content['additional-text'] = array(
          '#markup' => l($label, "node/{$node->nid}/parse-marcxml-new", array("attributes" => array("class" => "generate-stub"))), '#weight' => 10, 
        );
        $node->content['additional-text'] = array(
          '#markup' => 
       			l(t("Preview titles"), "node/{$node->nid}/preview-titles", array("attributes" => array("class" => "generate-stub"))) . ' ' . 
       			l($label, "node/{$node->nid}/parse-marcxml-new2", array("attributes" => array("class" => "generate-stub"))), '#weight' => 10, 
        ); 
        $view = views_embed_view("repository_item_by_recordsets", "embed_1", $node->nid);
         $node->content['view-repo-items'] = array(
          '#markup' => $view, '#weight' => 20, 
        );  
      }
      break;

  }
}

/**
 * initializes new item repos node
 *
 * @return $node
 *   the new skeletal node passed to the parser
 */
function _cals_prepare_new_item_repos() {

  new StdClass();
  $node->type = 'repository_item';
  $node->language = LANGUAGE_NONE;
  node_object_prepare($node);
  return $node;
}

/**
 * import / create skeletal marc records, i.e., just the title
 *
 * @param $node
 *   the node passed to the parser
 */
function _cals_import_skeletal_records($node) {
  $max = 50; //clear buffer, etc.
  ini_set('memory_limit', '1024M');
  ini_set('max_execution_time', '600');
  global $user;
  //module_load_include('inc', 'entity', 'includes/entity.controller');
  foreach (taxonomy_get_vocabularies() as $k => $v) {
    $arr_tax[$v->name] = $k;
  } 

  $arr_s3 = array();
  if (!empty($node->field_file_csv)) {
    $file_s3 = drupal_realpath($node->field_file_csv[LANGUAGE_NONE][0]['uri']); 
    $arr_s3 = _cals_get_array_csv_by_file($file_s3);
  
  }
  
  $file = drupal_realpath($node->field_marc_xml_file[LANGUAGE_NONE][0]['uri']); // FILE_FOLDER . ;
  //to track errors
  libxml_use_internal_errors(true);
  //load file
  $xml = simplexml_load_file($file);
  

  if ($xml===FALSE) {
    drupal_set_message(t("Oops, could not parse the file. Might not be valid xml?"), "error");
     foreach (libxml_get_errors() as $error) {
        drupal_set_message($error->message, "error");
    }
    drupal_goto("node/" . $node->nid);
  } 
  
  $num = 0;
  $parsed = array();//track some details re. the parsing
  
  foreach ($xml->children(NAME_SPACE) as $record) {
    $arr = _cals_get_title_from_xml($record);
    $result = '';
    
    if (!isset($arr['repos']['title']) || strlen($arr['repos']['title']) == 0) return "Oops, there's a missing title in this record set!";
      $new_record = TRUE;
      if (isset($node->field_parsed_nodes[LANGUAGE_NONE][$num]) ) {
        $new_record = FALSE;
        $n = node_load($node->field_parsed_nodes[LANGUAGE_NONE][$num]['nid']);
        //added just in case the node reference field is not cleared.
        if (!isset($n->type) || $n-type != "repository_item") {
          //prepare new node
          $n = _cals_prepare_new_item_repos();
          $result .= "Skeletal record added. ";

        }
        else {
          $n->changed = time();
          $result .= "Skeletal record updated. ";
        }
        
                
      }
      else {
        //prepare new node
        $n = _cals_prepare_new_item_repos();
        $result .= "Skeletal record added. ";
        // Get the term's ID.

      }

      //we'll add string to xml field.
      $arr['xml_record'] = $record->saveXML();

      if ($num < 10000) {
        //if ($new_record || $n->title != $arr['repos']['title'] || empty($n->field_xml_string)) {
          $n->status = 0;
          $n->title = $arr['repos']['title'];
          
          $n->field_xml_string[LANGUAGE_NONE][]['value'] = $arr['xml_record'];
  
          if (count($arr_s3)) {
            if (isset($arr['repos']['field_system_control_number'][0])) {
              $tmp = $arr['repos']['field_system_control_number'][0];
              if (array_key_exists($tmp, $arr_s3)) {
                $n->field_s3_path[LANGUAGE_NONE] = array();
                $n->field_s3_path[LANGUAGE_NONE][0]['value'] = $arr_s3[$tmp];
                $result .= "added s3 path.";
              }
              
            }
          
          }
          //save the new/existing repository item node  
          $n->field_record_set[LANGUAGE_NONE][0]['nid'] = $node->nid;
          $n->field_access_restrictions[LANGUAGE_NONE][0]['value'] = $node->field_access_restrictions[LANGUAGE_NONE][0]['value'];
          node_save($n);
          $result  = l(t("edit"), "node/" . $n->nid . "/edit" ) . " | " . l(t("view"), "node/" . $n->nid) . " - {$n->title}" 
            . " " . $result;  
          
        //} 
        //$node->field_parsed_nodes[LANGUAGE_NONE][$num]['nid'] = $n->nid;
        
      } 
      //save every 50 items
      //if (($num % $max) == 0) node_save($node);
    
    $parsed[] = $result;
    $num++;
  }
  $node->field_status[LANGUAGE_NONE][0]['value'] = 2;
  
  //save one last time.
  node_save($node);

  $vars = array("items" => $parsed, "title" => "parsed list: {$num} records", "type" => "ol", "attributes" => array());
  $vars = theme_item_list($vars); 
  drupal_set_message(filter_xss($vars, $allowed_tags = array('a', 'em', 'strong', 'cite', 'blockquote', 'code', 'ul', 'ol', 'li', 'dl', 'dt', 'dd')));
  drupal_goto("node/" . $node->nid);

}  


/**
 * fixes single node oclc number.
 *
 * @param $node
 *   the node passed to the parser
 */
function _cals_importer_update_oclc_numbers_single_node($node) {

  _cals_importer_update_oclc_numbers_query($node);
  drupal_goto("node/" . $node->nid);

}

/**
 * move OCoLC into proper field
 */
function _cals_importer_fix_oclc_numbers_batch(&$entity, $context = array()) {
  if (isset($entity->nid)) {
    $node = node_load($entity->nid);
    //safety check to make sure we're parsing repos items!!    
    $content_types = array('repository_item');
    if (in_array($node->type, $content_types)  ) {
      _cals_importer_update_oclc_numbers_query($node);
      drupal_set_message(t('OCLC Number updated for ') . l($node->title, "node/" . $node->nid . "/edit") ); 
      
    }
    else{
      drupal_set_message(t("Invalid selection: not a repos item"));
    }

  }//end main if
 
  return "";
  
}

function _cals_importer_update_oclc_numbers_query($node) {

  $vals = $node->field_system_control_number[LANGUAGE_NONE];
  //reset sys control number
  $node->field_system_control_number[LANGUAGE_NONE] = array();
  foreach($vals as $value) {
    $val = $value['value'];
    if(strpos($val, "(OCoLC)") !== false) {
      if (_cals_isvalid_oclc_number($val) === 1) {
        $node->field_oclc_number[LANGUAGE_NONE][]['value'] = $val; 
      } 
    }
    else { //repopulate the sys control numbers
      $node->field_system_control_number[LANGUAGE_NONE][]['value'] = $val;
    } 
    
  }
  _cals_delete_duplicate_oclc_numbers($node);
  node_save($node);
}


/**
 * checks validity of oclc number
 *
 * @param $string
 *   the string value passed to the function
 * @return integer
 *   returns 1 if true; 0 if false
 */
function _cals_isvalid_oclc_number($string) {
  $value = trim(str_replace("(OCoLC)", "", $string));
  $is_valid = 0;
  return (ctype_digit($value) !== false || is_int($value) !== false) ? 1 : 0;
}

/**
 * loops thru oclc_number values to strip out duplicates
 *
 * @param $node
 *   the node, passed by reference
 */

function _cals_delete_duplicate_oclc_numbers(&$node){
  if(!empty($node->field_oclc_number)) {
    $arr = array();
    foreach($node->field_oclc_number[LANGUAGE_NONE] as $k => $v) if(!in_array($v['value'], $arr)) $arr[] = $v['value'];
    $node->field_oclc_number[LANGUAGE_NONE] = array();
    //if multiple oclc numbers, throw an error message
    if(count($arr) > 1) {
      drupal_set_message(t("There are multiple OCLC numbers. Please check entry: ") . 
        l($node->title, "node/" . $node->nid . "/edit") );  
    } 
    foreach($arr as $val)   $node->field_oclc_number[LANGUAGE_NONE][] = array("value" => $val);
  }
}



/**
 * update / add system control numbers
 */
function _cals_importer_update_system_control_numbers(&$entity, $context = array()) {
  if (isset($entity->nid)) {
    $node = node_load($entity->nid);
    //safety check to make sure we're parsing repos items!!    
    $content_types = array('repository_item');
    if (in_array($node->type, $content_types)  ) {
      _cals_parse_system_control_number($node);
      drupal_set_message(t('%string System Control Numbers updated', array('%string' => $node->title)));
    }
    else{
      drupal_set_message(t("Invalid selection: not a repos item"));
    }

  }//end main if
 
  return "";
  
}

/**
 * load node, pull out system control numbers, save node 
 */

function _cals_parse_system_control_number($node) {
  $xml = _cals_get_marc_xml_string($node);
  if($xml === 0) return;

  $tmp = $xml->xpath("//marc:datafield[@tag='035']/marc:subfield[@code='a']");

  //$tmp = $xml->xpath("//marc:datafield[@tag='035']");
  unset($node->field_system_control_number);
  
  if (count($tmp)) {
  
    foreach ($tmp as $me) {
      $val = (string) $me;
      $node->field_system_control_number[LANGUAGE_NONE][]['value'] = $val;  
      drupal_set_message(t('%string System Control Numbers updated', array('%string' => $node->title)));

    }
  
  }
  else {
    $node->field_system_control_number[LANGUAGE_NONE][0]['value'] = 0;  
    drupal_set_message(t('%string System Control Numbers updated', array('%string' => $node->title)));


  }
  node_save($node);
  return '';  
}



/**
 * update Access Restrictions, i.e., 506 field
 */

function _cals_importer_update_licensed_access(&$entity, $context = array()) {
  if (isset($entity->nid)) {
    $node = node_load($entity->nid);
    //safety check to make sure we're parsing repos items!!    
    $content_types = array('repository_item');
    if (in_array($node->type, $content_types)  ) {
      _cals_parse_licensed_access($node);
    }
    else{
      drupal_set_message(t("Invalid selection: not a repos item"));
    }

  }//end main if
 
  return "";
  
}



/**
 * load node, pull out "restrictions". Separating it this way allows us to also include
 * this as part of the node/%node/parse-rights-access pattern.
 */

function _cals_parse_licensed_access($node) {
  $xml = _cals_get_marc_xml_string($node);
  if($xml === 0) return;
  
  $str = 'xyz';//placeholder string
  $tmp = $xml->xpath("//marc:datafield[@tag='506']/marc:subfield[@code='a']");
  if (!count($tmp)) {
    drupal_set_message(t('%string  Access Restriction not updated (no 506 element).'), array('%string' => $node->title));
    return '';
  }
  $str = (string) $tmp[0];
  $tmp = strpos(strtolower($str), "restricted");
  $node->field_access_restrictions[LANGUAGE_NONE][0]['value'] = (is_numeric($tmp)) ? 1 : 0; 
    
  node_save($node);
  drupal_set_message(t('%string  Access Restriction updated.'), array('%string' => $node->title));
  return '';  

}
//deprecate?
function _cals_get_subjects($xml) {
  
  //let's grab the date issued!
  $have_date = FALSE;
  $date = '';
  $tmp = $xml->xpath("//marc:datafield[@tag='008']");
  if (count($tmp)) {
    $str = (string) $tmp[0];
    return _cals_get_date_from_008($str);
  }
  if ($have_date === FALSE) {
    $tmp = $xml->xpath("//marc:datafield[@tag='264']/marc:subfield[@code='c']");
    if (count($tmp)) {
      $str = (string) $tmp[0];
      return _cals_get_iso_date($str);
    }
        
  } 
  if ($have_date === FALSE) {
    $tmp = $xml->xpath("//marc:datafield[@tag='260']/marc:subfield[@code='c']");
    if (count($tmp)) {
      $str = (string) $tmp[0];
      return _cals_get_iso_date($str);
    }
        
  } 
  return $date;


}
/**
 * grabs the title from the record
 *
 * @param $record
 *   the record passed to the parser
 */

function _cals_get_title_from_xml($record) {
  $arr = array();
  //loop thru datafields
  $arr['repos']['title'] = '';
  foreach ($record->children(NAME_SPACE)->datafield as $datafield) {
    $tag = (string) $datafield->attributes()->tag;
    $ind1 = (string) $datafield->attributes()->ind1;
    $ind2 = (string) $datafield->attributes()->ind2;
    
    
    foreach ($datafield as $subfield) {
      $code = (string) $subfield->attributes()->code;
      $str = trim((string) $subfield);
      $str = trim($str);

      switch ($tag) {
        case 245:
          if ($code == 'a') $arr['repos']['title'] =  $str;
          if ($code == 'b') $arr['repos']['title'] .=  " " . $str;
          $arr['repos']['title'] = _cals_get_truncated_value($arr['repos']['title'], 250);
          break;
          
        case "035":
          if ($code == 'a') {
            if (strpos($str, "(OCoLC)") !== false) {
              $arr['repos']["field_oclc_number"][] = $str;
            }
            else {
              $arr['repos']["field_system_control_number"][] = $str;
            }
          } 
          break;  
      }
    }
  }
  return $arr;
  
}


/**
 * Get an array of cataloging agencies
 *
 * @return
 *   an array of cataloging agencies
 */

function _cals_importer_get_array_cataloging_agency() {
  /*
  1|Original Cataloguing agency (NR)
  2|transcribing_agency
  3|modifying_agency
  
  */
 return array(
  "a" => 1, //"original_cataloguing_agency", 
  //"b" => "cataloguing_language", 
  "c" => 2, //"transcribing_agency",
  "d" => 3, // "modifying_agency",
  );


}
 
/** 
 * @param $arr
 *   the value (array) returned by 
 *
 * @return
 *   $val, a string
 */
function _cals_importer_get_string($arr) {
  $val = (string)$arr[0];
  return htmlspecialchars(trim($val));
}

 
/**
 * To deprecate?
 */

function _cals_importer_xml2php($xml) {
  $fils = 0;
  $tab = FALSE;
  $array = array();

  foreach ($xml->children() as $key => $value) {   
    $child = _cals_importer_xml2php($value);
    //To deal with the attributes
    foreach ($node->attributes() as $ak => $av) {
      $child[$ak] = (string)$av;
    }
    //Let see if the new child is not in the array
    if ($tab == FALSE && in_array($key, array_keys($array))) {
    //If this element is already in the array we will create an indexed array
      $tmp = $array[$key];
      $array[$key] = NULL;
      $array[$key][] = $tmp;
      $array[$key][] = $child;
      $tab = TRUE;
    }
    elseif ($tab == TRUE) {
      //Add an element in an existing array
      $array[$key][] = $child;
    }
    else{
      //Add a simple element
      $array[$key] = $child;
    }
    $fils++;       
  }
  if ($fils==0) return (string)$xml;
  return $array;
}